---
title  : La Función que no lo era
slug   : la-funcion-que-no-lo-era
author : Javier Vélez
date   : Jun 2022
---

# Resumen

Comencemos por el más sencillo de los 3 tipos de evaluación, aquel que prescribe el momento exacto del tiempo en el que se deben evaluar las expresiones que aparecen en el código fuente. Encontrar una definición formal que permita diferenciar los dos modelos que se distinguen dentro de esta categoría es sencillo. La Evaluación impaciente evalúa cada expresión en el momento exacto del tiempo en que ésta es encontrada dentro del código fuente. La evaluación perezosa, por el contrario, posterga la evaluación de la expresión hasta que su valor es realmente demandado por el programa en ejecución.

# Introducción

El mejor ejemplo para ilustrar esta diferencia lo encontramos en las expresiones lógicas. Imaginemos una construcción de la forma x && y, que como sabemos corresponde a la conjunción lógica de las sub-expresiones en x e y. El modelo de evaluación impaciente evaluaría vorazmente las partes izquierda y derecha de la expresión y sólo cuando se obtuviera el valor de cada una de ellas se computaría el resultado final. La evaluación perezosa actúa de una manera más inteligente aplicando una estrategia de evaluación que, como hemos descrito, depende de la semántica de la operación posterior. En este ejemplo, primero se computa el valor en x y sólo si éste es cierto el compilador da continuidad a la evaluación de la sub-expresión en y dado que se sabe que si x fuera falso la operación de conjunción lógica arrojaría un valor lógico falso, con independencia del valor de la y. Un razonamiento similar puede encontrarse para el resto de operadores lógicos.

> **Contrato Compositivo**. Poco relevante la utilización de uno u otro de estos modelos de evaluación. Pero lo cierto es que el uso de evaluación perezosa comporta importantes ventajas con respecto al otro modelo de evaluación.

La evaluación perezosa actúa de una manera más inteligente aplicando una estrategia de evaluación que, como hemos descrito, depende de la semántica de la operación posterior. En este ejemplo, primero se computa el valor en x y sólo si éste es cierto el compilador da continuidad a la evaluación de la sub-expresión en y dado que se sabe que si x fuera falso la operación de conjunción lógica arrojaría un valor lógico falso, con independencia del valor de la y. Un razonamiento similar puede encontrarse para el resto de operadores lógicos.

- **Codificación.** La evaluación perezosa permite alcanzar un modelo de programación defensivo basado en aserciones [+] que resulta generalmente más sinóptico y sencillo de leer y entender. En lugar de comprobar las precondiciones de una operación a base de un abuso de sentencias y expresiones condicionales se utilizan expresiones lógicas como prefijo de las operaciones a realizar para que operen de guarda que dispara la ejecución de la operación a la derecha sólo si se satisface cierta condición ambiental. En el código (A) del Listado 1 pueden verse algunos ejemplos de este uso canónico de construcciones.

- **Recursión.** De forma similar al caso anterior, los esquemas de diseño funcional recursivo también se prestan mucho a hacer uso de este tipo de construcciones. En el código (B) del Listado 1 aparece un ejemplo de función de búsqueda recursiva que determina si un elemento x se encuentra dentro de un vector xs. Tal función consiste en una sola expresión que indica que el vector contendrá al elemento, si éste se encuentra en la posición de análisis en curso p o está en alguna posición posterior a este índice, comenzando desde el 0. Y todo ello siempre que p no supere la longitud del vector. En este caso, la evaluación perezosa nos servirá para que se pare la recursión cuando esta última condición sobre p deje de ser cierta o el elemento se haya encontrado.

- **Rendimiento.** La evaluación perezosa también puede ser relevante en temas de rendimiento. El código (C) del Listado 1 muestra una función similar a la anterior, pero en este caso aplicando búsqueda binaria. Básicamente, en cada iteración recursiva, el vector se parte - de forma imaginaria - en 2 subvectores iguales con ayuda de dos índices posicionales p y q. Buscar el elemento x consiste en recurrir con la búsqueda en cada subvector. El proceso terminará cuando se llegue a alguna situación unitaria donde py q coincidan y pueda comprobarse que en ese punto reside el elemento buscado. La ventaja de la evaluación perezosa en este escenario consiste en que todo el proceso de encadenamiento compositivo por operaciones de disyunción lógica se para automáticamente en cuanto se encuentra la primera coincidencia ahorrando muchos ciclos de cómputo. Recuerde que el modelo de ejecución es secuencial y que las operación has no se lanzan en paralelo.

De todo lo anterior podemos colegir que el modelo de evaluación perezosa resulta bastante más conveniente que su contrapartida impaciente. No obstante, debemos ser conscientes de que en este modelo el orden de escritura de las sub-expresiones es relevante. Defender ante la matemática que computacionalmente no es equivalente la construcción x && y a su simétrica y && x es algo que, cuando menos, resulta comprometido.

1. **Recursión.** De forma similar al caso anterior, los esquemas de diseño funcional recursivo también se prestan mucho a hacer uso de este tipo de construcciones. En el código (B) del Listado 1 aparece un ejemplo de función de búsqueda recursiva que determina si un elemento x se encuentra dentro de un vector xs. Tal función consiste en una sola expresión que indica que el vector contendrá al elemento, si éste se encuentra en la posición de análisis en curso p o está en alguna posición posterior a este índice, comenzando desde el 0. Y todo ello siempre que p no supere la longitud del vector. En este caso, la evaluación perezosa nos servirá para que se pare la recursión cuando esta última condición sobre p deje de ser cierta o el elemento se haya encontrado.

2. **Rendimiento.** La evaluación perezosa también puede ser relevante en temas de rendimiento. El código (C) del Listado 1 muestra una función similar a la anterior, pero en este caso aplicando búsqueda binaria. Básicamente, en cada iteración recursiva, el vector se parte - de forma imaginaria - en 2 subvectores iguales con ayuda de dos índices posicionales p y q. Buscar el elemento x consiste en recurrir con la búsqueda en cada subvector. El proceso terminará cuando se llegue a alguna situación unitaria donde py q coincidan y pueda comprobarse que en ese punto reside el elemento buscado. La ventaja de la evaluación perezosa en este escenario consiste en que todo el proceso de encadenamiento compositivo por operaciones de disyunción lógica se para automáticamente en cuanto se encuentra la primera coincidencia ahorrando muchos ciclos de cómputo. Recuerde que el modelo de ejecución es secuencial y que las operación has no se lanzan en paralelo.


La buena noticia es que este tipo de evaluación perezosa - la que opera sobre el espacio de expresiones lógicas, también llamada evaluación en cortocircuito - está en la mayoría de lenguajes actuales. Es el caso de nuestro lenguaje JavaScript. No obstante, hay otros escenarios donde resultaría importante disponer de evaluación perezosa y que no quedan cubiertos por JavaScript. Me estoy refiriendo a la evaluación en las llamadas a funciones.

  <figure>
    <img src="/images/articles/image.01.png" alt="Consumismo Digital">
    <figcaption>Consumismo Digital. El mejor ejemplo para ilustrar esta el valor de cada una de ellas diferencia lo encontramos en las expresiones lógicas.</figcaption>
  </figure>

El mejor ejemplo para ilustrar esta diferencia lo encontramos en las expresiones lógicas. Imaginemos una construcción de la forma x && y, que como sabemos corresponde a la conjunción lógica de las sub-expresiones en x e y. El modelo de evaluación impaciente evaluaría vorazmente las partes izquierda y derecha de la expresión y sólo cuando se obtuviera el valor de cada una de ellas se computaría el resultado final. La evaluación perezosa actúa de una manera más inteligente aplicando una estrategia de evaluación que, como hemos descrito, depende de la semántica de la operación posterior. En este ejemplo, primero se computa el valor en x y sólo si éste es cierto el compilador da continuidad a la evaluación de la sub-expresión en y dado que se sabe que si x fuera falso la operación de conjunción lógica arrojaría un valor lógico falso, con independencia del valor de la y. Un razonamiento similar puede encontrarse para el resto de operadores lógicos.

El mejor ejemplo para ilustrar esta diferencia lo encontramos en las expresiones lógicas. Imaginemos una construcción de la forma x && y, que como sabemos corresponde a la conjunción lógica de las sub-expresiones en x e y. El modelo de evaluación impaciente evaluaría vorazmente las partes izquierda y derecha de la expresión y sólo cuando se obtuviera el valor de cada una de ellas se computaría el resultado final. La evaluación perezosa actúa de una manera más inteligente aplicando una estrategia de evaluación que, como hemos descrito, depende de la semántica de la operación posterior. En este ejemplo, primero se computa el valor en x y sólo si éste es cierto el compilador da continuidad a la evaluación de la sub-expresión en y dado que se sabe que si x fuera falso la operación de conjunción lógica arrojaría un valor lógico falso, con independencia del valor de la y. Un razonamiento similar puede encontrarse para el resto de operadores lógicos.