---
title  : El proxy que no lo era
slug   : el-proxy-que-no-lo-era
author : Javier Vélez
date   : Jun 2022
---

En los últimos tiempos parece haberse popularizado la idea de que las soluciones de software deben desarrollarse de acuerdo a un nuevo y revolucionario modelo arquitectónico. Se dice que este modelo no solamente confiere a estas soluciones unas propiedades características muy deseables sino que además ayuda enormemente en los procesos de construcción y desarrollo. En función de autores, comunidades y estilos, este modelo ha recibido diversos nombres a cada cual más rimbombante y pretencioso que el anterior. Arquitecturas de cebolla [1], arquitecturas limpias [2] o – para mi la más hilarante y estridente de todas – las arquitecturas hexagonales [3].

Es fácil hacerse una idea general de la propuesta arquitectónica que estos modelos hacen en relación a los procesos de desarrollo de soluciones de software. Basta con rascar un poco en la blogosfera actual o visitar los recientes eventos de IT para encontrarse con una pléyade de artículos y charlas introductorias que nos invitan a conocer esta nueva revolución en el mundo del diseño de software. No obstante, antes de pasar a comentar el dudoso valor añadido que aporta este tipo de contribuciones a la comunidad, describiremos de una manera objetiva la propuesta que se hace desde estos modelos. Aunque existen someras diferencias entre ellos, todos resultan francamente similares. Por tanto, nos centraremos en describir aquí el modelo que está cogiendo más tracción y que paradójicamente es el de las arquitecturas hexagonales.

Una arquitectura hexagonal conceptualiza la construcción de soluciones de software en base a la identificación de una colección de puertos y el desarrollo de una serie de adaptadores que se conectan a dichos puertos. Esta idea permiten implementar el modelo de negocio del aplicativo que se desea construir de una manera aislada de cualquier tipo de dependencia exterior de manera que los puertos se corresponden con puntos de entrada y salida a un núcleo funcional que puede ser atacado por distinto tipos de clientes o sistemas.

Ejemplo de una arquitectura hexagonal para un problema de ejemplo

Figura 1. Ejemplo de una arquitectura hexagonal para un problema de ejemplo.
Por ejemplo, si tenemos en cuenta el modelo arquitectónico hexagonal que se presenta en la figura 1, observamos que el funcional de negocio desarrollado de manera nuclear, en efecto, se encuentra completamente aislado de cualquier tipo de dependencia y que éste puede ser atacado por distintos tipos de sistemas desde diferentes flancos. En el ejemplo, con responsabilidades de front existe un adaptador para la web, otro para facilitar la integración con servicios en REST y uno último para realizar cómodamente la depuración basada en pruebas unitarias y TDD. Asimismo, desde el back, el soporte a la persistencia – o como algunos gustan en decir ahora, los sistemas de registro - están desacoplados de manera que puede utilizarse indistinta y simultáneamente una solución relacional o no SQL en sus diferentes sabores al mas puro estilo políglota como está últimamente en boga [4]. Otros puntos de desacoplamiento que aparecen en la figura de ejemplo tienen que ver con cuestiones de autenticación, monitorización e incluso virtualización asumiendo que tales capacidades fueran requerimientos demandados por el problema.

En sentido estricto, esta propuesta no es susceptible de critica alguna. Jamás señalaré a nadie que defienda las bondades del desacoplamiento en relación a la construcción de software. Los productos obtenidos de esta manera resultan más reutilizables, más modulares y más mantenible que otras aproximaciones. Si este modelo se considera como un mero marco conceptual que ayuda a adquirir buenas prácticas en procesos de diseño y desarrollo de la solución que estamos construyendo bienvenido sea. Lo que sí resulta un poco molesto es que a este discurso se le de el nombre de arquitectura y más aún que se le incluya el epíteto de hexagonal.

Con frecuencia me siento peregrino en tierra de infieles cuando reclamo recurrentemente la necesidad de hacer un uso adecuado del lenguaje. Me he encontrado con muchos informáticos que se jactan de ser técnicos todo terreno muy competentes y para los que estos debates les resultan bizantinos e inocuos. Pero Wittgenstein ya hace muchos años que nos lo advirtió [5].

El pensamiento es una representación de la realidad. La realidad es aquello que se puede describir con el lenguaje, por eso los límites de mi lenguaje son los límites de mi mundo.

En este sentido, y suscribiendo la importancia de un uso correcto del lenguaje para no volvernos locos, podemos argumentar que las arquitecturas hexagonales no son ni arquitecturas ni hexagonales:

La arquitectura que no lo era. Una arquitectura de software establece una colección de restricciones estructurales que condicionan la anatomía, funcionamiento e interacción entre las partes de un producto software [6]. Así por ejemplo, en los aplicativos monolíticos, las arquitecturas por capas [7] promueven la idea de que el software debe articularse en base a una colección de capas de código que se responsabilizan de distintos aspectos transversales, tales como la presentación de datos, el control de la interacción o la integración con fuentes externas y donde la restricción fundamental estriba en que cada componente dentro de una capa sólo puede hablar con sus capas adyacentes. Por su parte, las arquitecturas MVC [8] estresan la importancia de mantener completamente separados en artefactos independientes la lógica de negocio, la lógica de presentación y la lógica de control como intermediador entre ambos. Las arquitecturas de pipes & filters [9] se basan en el diseño de canales de transformación funcional por los que se procesan datos bajo la hipótesis de que dichas transformaciones nunca pueden depender del estado interno. Y así podríamos seguir describiendo distintos tipos de arquitecturas que se han empleado con éxito a lo largo de la historia en los procesos de desarrollo. Todos estos modelos se ajustan a la definición anterior: restricciones estructurales que condicionan el funcionamiento y las dependencias entre las partes Las arquitecturas hexagonales promueven la idea de desacoplamiento pero, ¿cuál es su propuesta en relación con la organización estructural del código? Si se leen los artículos con atención observamos que no existe propuesta alguna lo que conduce a pensar que este modelo no es una arquitectura sino una colección de buenas prácticas.

El hexágono que no lo era. Quizá para salvar los muebles del problema de desestructuración que acabamos de describir, el autor originalmente pensó que sería buena idea afirmar que este tipo de arquitecturas tiene una morfología hexagonal y que están basadas en el uso de puertos y adaptadores. Afirmar esto último es poco menos que no decir nada ya que toda arquitectura está basada en procesos de composición de código y estos se pueden en esencia interpretar en términos de conectores y adaptadores. Pero quizá lo más escandaloso respecto a la propuesta es la afirmación anterior de que las arquitecturas son hexagonales. El mismo autor reconoce que el número de flancos en torno a los cuales puede articularse el desacoplamiento basado en puertos y adaptadores es irrelevante por cuanto a la postre depende de las particularidades del problema. Por tanto la hexagonalidad también queda en entredicho.